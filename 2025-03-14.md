# 2025-03-14 : 알고리즘/컴퓨터 시스템/JavaScript

오늘은 알고리즘, 컴퓨터 시스템, JavaScript를 공부했다. 각각 공부한 시간은 다음과 같다.

- 알고리즘: 2시간

- 컴퓨터 시스템: 6시간

- JavaScript: 1시간

## 💙 1. 알고리즘
백준에서 파이썬을 사용해 알고리즘을 풀었다. 파이썬을 다룬지 오래돼서 기억이 가물가물한데, 그래서 감을 되찾기 위해 브론즈 문제들을 해결했다. 오늘 푼 문제들은 아래와 같다.

> 2557, 10869, 2588, 9498, 2753, 1085, 2739, 1085, 2739, 10950, 2438, 10871, 2562, 8958

파이썬은 정말 사용자 친화적인 언어라는 것을 다시 한 번 느꼈다.

## 💙 2. [CSAPP] Ch1. 컴퓨터 시스템으로의 여행
오늘부터 CSAPP(Computer System A Programmer's Perspective) 책을 읽는다. 책을 대략적으로 봤을 때, 내게는 생소한 용어들도 많고 들어는 봤지만 정확히 무엇인지 모르는 단어들도 많았다. 따라서 책 내용을 >정리하기 앞서 책에서 설명하지 않지만 반복적으로 언급되는 용어들을 정리하겠다.

### 😶 들어가기 전 용어 정리
- 컴포넌트
- 컴파일/컴파일러
- 프로시저
- 버퍼/버퍼 오버플로우
- 링커/링킹
- 컨텍스트
- 라이브러리
- OS(운영체제)
- 유닉스/리눅스
- 포팅
- 인스트럭션

#### ✅ 컴포넌트

> 재사용이 가능한 각각의 독립된 모듈

컴포넌트는 독립적인 소프트웨어 모듈로, 재활용이 가능하므로 이후 시스템을 유지보수하는데 있어 교체가 가능하다. 이 책에서 다룰 시스템에서의 컴포넌트는 '컴퓨터가 동작하는 데 필요한 핵심 구성 요소'를 말한다. 크게 하드웨어와 소프트웨어로 나눌 수 있다.

1. 하드웨어 컴포넌트
   
   컴퓨터 시스템의 물리적인 장치들
   
   예) CPU, RAM, HDD/SSD(저장장치) 등

2. 소프트웨어 컴포넌트
   
   운영체제(OS) 및 각종 응용 프로그램들

   예) 운영체제, 드라이버, 응용 프로그램, 미들웨어, 펌웨어 등

#### ✅ 컴파일/컴파일러

> 컴파일: 프로그래밍 언어로 작성된 소스 코드를 컴퓨터가 이해할 수 있는 기계어로 변환하는 과정
> 
> 컴파일러: 컴파일하는 프로그램

프로그래머가 C, C++, Java, Python 등을 통해 작성한 코드(고수준 언어)를 컴퓨터가 이해할 수 있는 언어(기계어)로 변환하는 프로그램을 컴파일러, 그 과정을 컴파일이라고 한다.

#### ✅ 프로시저

> 특정한 작업을 수행하는 명령어들의 집합

함수와 비슷한 개념이라고 생각하면 된다.

#### ✅ 버퍼/버퍼 오버플로우

> 버퍼: 데이터를 임시로 저장하는 공간
> 
> 버퍼 오버플로우: 버퍼의 크기보다 들어오는 데이터의 양이 많아지며 생기는 문제

버퍼란 데이터가 한 번에 잘 전달되지 않을 때, 잠시 저장해서 원활하게 처리하는 메모리 공간이다. 많이 사용되는 단어인 버퍼링의 버퍼가 이 버퍼이다. 데이터를 전송하거나 처리할 때 속도 차이가 발생하면, 데이터 손실이나 지연이 생길 수 있다. 이때 버퍼링을 사용해서 속도 차이를 조절하여 원활하게 데이터가 처리되는 것이다. 흔히 보는 '버퍼링 중...'이라는 문구는 미리 다운로드한 데이터를 버퍼에 저장하고, 재생 속도를 맞추는 과정이라는 말이다. 이때 버퍼 크기보다 더 많은 데이터가 들어오면 **버퍼 오버플로우**가 발생한다.

- ❓ 버퍼링은 버퍼 오버플로우를 해결하기 위한 과정인가?
  
  아니다. 버퍼링을 잘 설계하면 버퍼 오버플로우를 방지할 수는 있지만, 버퍼링의 목적은 버퍼 오버플로우를 해결하기 위한 것은 아니다.

  버퍼링은 데이터의 흐름(속도)를 조절하는 기술이고, 버퍼 오버플로우는 데이터의 크기(양)이 초과되어서 발생하는 문제이기 때문이다.

#### ✅ 링커/링킹

> 링커: 링킹을 담당하는 프로그램
> 
> 링킹: 여러 코드 조각을 합쳐서 실행할 수 있도록 만드는 과정

링킹이란 컴파일러가 만든 결과물들을 하나로 합쳐 바로 실행이 가능한 하나의 파일로 만드는 작업이다. 즉, 각각의 코드 조각을 연결(Link)해서 실행 파일을 만드는 단계이다.

#### ✅ 라이브러리

> 미리 지식/기능들을 모아둔 집합소

라이브러리는 응용 프로그램 개발을 위해 자주 사용하는 기능들을 개발자들이 필요와 목적에 따라 사용할 수 있도록 모듈화된 프로그램 모음이다.

#### ✅ OS(운영체제)

> 컴퓨터 시스템의 핵심 소프트웨어

OS는 컴퓨터 하드웨어와 응용 프로그램 간의 상호작용을 관리하고 제어하는 역할을 한다. 운영체제의 종류로는 윈도우, macOS, 유닉스, 리눅스가 있다.


#### ✅ 유닉스/리눅스

> 유닉스: 규모가 큰 기업에서 선호하는 OS
> 
> 리눅스: 기업보다는 개발자나 일반인 등이 많이 사용하는 OS

리눅스는 유닉스를 기반으로 만들어진 무료(오픈소스) OS이다. 두 OS 모두 다중 사용자, 멀티태스킹, 다중 스레드를 지원하는 네트워크 OS라 서버로 작동하는데 최적화 되어있다.

#### ✅ 포팅

> 동작할 수 있도록 하는 과정

포팅 = '이식'이라고 이해하면 쉽다. 소프트웨어를 다른 플랫폼(CPU 및 운영체제)에서도 동작할 수 있도록 변환하는 것이다. 

#### ✅ 인스트럭션

> 컴퓨터가 수행할 작업을 정의하는 명령어

인스트럭션은 컴파일된 소스 코드로 실행 파일 한 줄 한 줄의 명령어를 뜻한다.

### ✨ 1.0 들어가며

아래는 C로 작성된 간단한 코드이다. 이를 앞으로 hello 프로그램으로 칭한다.

```C
# include <studio.h>

int main()
{
    printf("hello, world\n");
    return 0
}
```

시스템에 대한 공부는 프로그래머가 코드를 실행한 후 어떤 일이 일어나는지에 관한 것을 배우는 것부터 시작한다. 1장에서는 위 시스템이 실행되고, hello world를 출력하고, 종료되는 과정을 배운다.

### 🔶 1.1 정보는 비트와 컨텍스트로 이루어진다

#### 😶 용어 정리

> **비트/바이트**
>
> ✅ 비트 : 컴퓨터가 데이터를 저장할 수 있는 최소 단위
>
> ✅ 바이트: 컴퓨터 내에서 정보를 처리하는 가장 작은 단위
>
> 바이트는 프로그램의 텍스트 문자를 나타내며, 1바이트는 8비트로 이루어져 있다.

> **소스 프로그램**
>
> ✅ 소스 프로그램: 컴퓨터 프로그램을 사람이 읽을 수 있는 프로그래밍 언어로 기술한 텍스트 파일

> **텍스트 파일/바이너리 파일**
>
> ✅ 텍스트 파일: 오로지 아스키 문자들로만 이루어진 파일
> 
> ✅ 바이너리 파일: 텍스트 파일이 아닌 모든 파일

#### 😶 내용 정리
hello 프로그램은 소스 프로그램으로 시작하며, *hello.c*라는 텍스트 파일로 저장된다. 대부분의 컴퓨터 시스템은 텍스트 문자를 아스키 표준을 사용하여 표시하므로, *hello.c* 프로그램은 연속된 바이트들로 파일에 저장된다. 이는 기본 개념을 분명히 보여준다. 모든 시스템 내부의 정보(디스크 파일, 메모리상의 프로그램, 데이터, 네트워크를 통해 전송되는 데이터)는 비트들로 표시된다. 서로 다른 객체들을 구분하는 유일한 방법은 이들을 바라보는 컨텍스트에 의해서다.

여기서 컨텍스트는 '우리가 데이터를 해석하는 기준이 되는 정보'를 말한다. 비트 자체는 무의미한 0과 1로 이루어져 있고, 컨텍스트를 부여해야 의미가 생긴다.

```plaintext
01000001 01000010 01000011
```

위 비트들은 아무런 의미가 없다. 그러나 비트에 '아스키 표준'과 '숫자'라는 컨텍스트를 부여한다면, 각각 'ABC'와 '16706'으로 해석된다. 같은 비트 데이터라도 컨텍스트에 따라 의미가 다르게 해석되는 것이다.

그러므로 컴퓨터 내에서 숫자들의 표현은 예상하지 못하는 방식으로 움직일 수 있는 유한한 근사값이다.

### 🔶 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.

#### 😶 용어 정리

> **컴파일러 드라이버**
>
> ✅ 컴파일 전체 과정을 관리하고 실행하는 프로그램
> 
> 컴파일러 드라이버란 전처리기(preprocessor), 컴파일러, 어셈블러, 그리고 링커를 사용자의 요구사항에 따라서 차례대로 실행시켜주는 프로그램이다. 대표적으로 gcc 가 바로 컴파일러 드라이버에 해당한다.

> **소스 프로그램**
>
> ✅ 소스 프로그램: 컴퓨터 프로그램을 사람이 읽을 수 있는 프로그래밍 언어로 기술한 텍스트 파일

> **텍스트 파일/바이너리 파일**
>
> ✅ 텍스트 파일: 오로지 아스키 문자들로만 이루어진 파일
> 
> ✅ 바이너리 파일: 텍스트 파일이 아닌 모든 파일

> **어셈블리어**
>
> ✅ 컴퓨터 프로그래밍의 저급 언어
>
> 어셈블리어는 컴퓨터 프로그래밍의 저급 언어로, 기계어에서 한 단계 위의 언어이다.

#### 😶 내용 정리
텍스트 파일인 *hello.c*를 시스템에서 실행시키기 위해서는 각 C 문장들을 프로그램들을 사용해 저급 기계어 인스트럭션들로 번역해야 한다. 이 인스트럭션들은 실행가능 목적 프로그램(=실행가능 목적 파일)이라고 하는 형태로 합쳐져서 바이너리 디스크 파일로 저장된다.

컴파일러 드라이버는 유닉스 시스템에서 다음과 같이 소스파일에서 오브젝트 파일로 번역한다:

```
linum > gcc -o hello hello.c
```

여기서 GCC 컴파일러 드라이버는 소스파일 hello.c를 읽어서 실행파일인 hello로 번역한다. 번역은 전처리, 컴파일, 어셈블리, 링크 총 4단계를 거쳐서 실행된다. 이 네 단계를 실행하는 프로그램들(전처리기, 컴파일러, 어셈블러, 링커)을 합쳐서 컴파일 시스템이라고 부른다.

> -*hello.c*→ 전처리 단계 -*hello.i*→ 컴파일 단계 -*hello.s*→ 어셈블리 단계 -*hello.o*→ 링크 단계 -*hello*→

각 단계를 더 구체적으로 알아보자.

- **전처리 단계**
  
  전처리기(cpp)는 본래의 C 프로그램을 #문자로 시작하는 디렉티브에 따라 수정한다. 예로, hello.c 파일 첫 줄의 #include<studio.h>는 전처리기에게 시스템 헤더파일인 studio.h를 프로그램 문장에 직접 삽입하라고 지시한다. 그 결과 일반적으로 .i로 끝나는 새로운 C 프로그램이 생성된다.

- **컴파일 단계**
  
  컴파일러(cc1)는 텍스트 파일 hello.i를 텍스트 파일인 hello.s로 번역하며, 이 파일에는 어셈블리어 프로그램이 저장된다. 이 프로그램은 다음과 같은 main 함수의 정의를 포함한다.
  ```
  1  main:
  2    subq    $8, %rsp
  3    movl    $.LCO, %edi
  4    call    puts
  5    movl    $0, %eax
  6    addq    $8, %rsp
  7    ret
  ```
  2~7줄에서는 한 개의 저수준 기계어 명령어를 텍스트 형태로 나타내고 있다. 어셈블리어는 여러 상위수준 언어의 컴파일러들을 위한 공통의 출력언어를 제공하기 때문에 유용하다. 예로, C와 Fortran 컴파일러는 둘 다 동일한 어셈블리어로 출력 파일을 생성한다.

- **어셈블리 단계**
  
  어셈블러(as)는 hello.s를 기계어 인스트럭션으로 번역하고, 이들을 재배치가능 목적 프로그램의 형태로 묶어서 hello.o라는 목적 파일에 그 결과를 저장한다. 이 파일은 main 함수의 인스트럭션들을 인코딩하기 위한 17바이트를 포함하는 바이너리 파일이다. hello.o파일을 텍스트 편집기로 열어보면 쓰레기 같은 데이터로 보일 것이다.

- **링크 단계**
  
  hello 프로그램이 C 컴파일러에서 제공하는 표준 C 라이브러리에 들어 있는 printf 함수를 호출하는 것에 주목할 필요가 있다. printf 함수는 이미 컴파일된 별도의 목적파일인 print.에 들어 있으며, 이 파일은 hello.o 파일과 어떤 형태로든 결합되어야 한다. 링커 프로그램(ld)이 이 통합작업을 수행한다. 그 결과인 hello파일은 실행가능 목적파일(즉, 실행파일)로 메모리에 적재되어 시스템에 의해 실행된다.

### 🔶 1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.

#### 😶 내용 정리

위에서 보았던 hello.c 프로그램의 경우 컴파일 시스템이 정확하고 효율적인 기계어를 만들어줄 것으로 기대할 수 있다. 그렇지만 우리는 3가지 중요한 이유로 컴파일 시스템의 동작을 이해할 필요가 있다.

- 프로그램 성능 최적화하기
  
  최신 컴파일러들은 복잡하고, 대게 우수한 코드를 생성한다. 효율적인 코드를 작성하기 위해서 컴파일러의 내부 동작을 알 필요는 없다. 그러나 C 프로그램 작성시 올바른 판단을 하기 위해서 기계어 수준 코드에 대한 기본적인 이해를 할 필요가 있으며, 컴파일러가 어떻게 C 문장들을 기계어 코드로 번역하는지 알 필요가 있다.

- 링크 에러 이해하기
  
  가장 당혹스러운 프로그래밍 에러는 링커의 동작과 관련되어 있곤 하다. 특히 큰 규모의 소프트웨어 시스템을 빌드하려는 경우에 더욱 그렇다.

- 보안 약점 피하기
  
  버퍼 오버플로우 취약성은 오랫동안 인터넷과 네트워크상의 보안 약점의 주요 원인으로 설명되었다. 이는 프로그래머들이 신뢰할 수 없는 곳에서 획득한 데이터의 양과 형태를 주의 깊게 제한해야 할 필요를 거의 인식하지 못하기 때문에 생겨난다. 안전한 프로그래밍을 배우는 첫 단계는 프로그램 스택에 데이터와 제어 정보가 저장되는 방식 때문에 생겨나는 영향을 이해하는 것이다.

## 💙 3. JavaScript

우선 생활코딩의 *WEB2 JavaScript* 강의로 공부할 계획이다.
### 1. 수업 소개

JavaScript란 **마법**으로 비유된다. JavaScript를 사용하면 그림처럼 멈춰있는 HTML을 영화처럼 움직이도록 만드는 것이 가능하기 때문이다. 정보를 담고 있는 정적인 HTML을 JavaScript는 동적으로 만드는 역할을 한다.

### 2. 수업의 목표

1. JavaScript는 사용자와 상호작용하는 언어이다.
2. 웹 브라우저는 한 번 화면에 출력되면 자기 자신을 바꿀 수 없다.

하지만 JavaScript를 이용하면 HTML을 바꿀 수 있다. 즉, **"JavaScript는 HTML을 제어하는 언어이다."**

### 3. HTML과 JS의 만남 : script 태그

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
    </head>
    <body>
        <h1>JavaScript</h1>
        <script>
            document.write(1+1);
        </script>
        <h1>html</h1>
        1+1
    </body>
</html>
```

동일한 1+1인데 JavaScript에서는 *2*, HTML에서는 *1+1*로 나온다. JavaScript가 동적인 언어라는 의미이다.

### 💡 느낀 점!

용어들을 하나하나 이해하고 넘어가려 하다보니 4페이지 읽는데 5시간이 걸렸다. 책이 천 페이지가 넘는데 다 읽을 수 있을지 의문이다. 갈수록 읽는 속도가 빨라질 거라고 믿는 수밖에...!