# 2025-03-26 : 알고리즘/컴퓨터 시스템

### 💡 오늘의 일정!

1. 오전(10:00 ~ 12:00)
   
   - 알고리즘 한 문제 풀기

2. 오후(13:00 ~ 18:00)

   - 자소서 쓰기
   - 해시 테이블 정리하기
   - 코어 타임
   - 알고리즘 한 문제 풀기
   
3. 저녁(19:00 ~ 23:00) 

   - 자소서 쓰기
   - 알고리즘 한 문제 풀기
  
## 💙 1. 알고리즘

## 💙 2. 코어타임

### 📌 해시테이블

#### ✅ 해시테이블이란?

- 자료구조중 하나
- 해시 맵, 해시 표와 동의어
- (Key, Value)로 데이터를 저장한다.
- 쉽게 말하자면, 이름표가 붙어있는 보관함이다.
- Key: 이름, Value: 보관함
- 이름을 말하면, '해시함수'가 보관함의 번호를 계산해서 알려준다.
- 그럼 보관함에서 바로 꺼낼 수 있다.
- 면접용 한 줄 설명: "해시테이블은 키를 해시함수로 변환해서 배열처럼 빠르게 접근할 수 있게 해주는 자료구조입니다."

#### ✅ 왜 써야 하는가?

- 엄청 빠르기 때문
- 진짜 엄청 빠르다.
- 어느정도냐면, 찾고, 넣고, 지우는 평균 시간 복잡도가 O(1)이다.
- 기존 자료구조인 이진탐색트리나 배열에 비해서도 굉장히 빠른 속도.

#### ✅ 해시테이블의 예시

- 파이썬에서 dict과 set이 바로 해시테이블이다.
- C 언어에는 해시테이블이 내장되어있지 않다. 그래서 직접 구현해야 함
- C++ 에서는 unordered_map, unordered_set
- Java 에서는 대표적으로 HashMap, HashSet, TreeMap

#### ✅ 해시테이블은 언제 써야 하는가?

1. 어떤 값이 있는지 빠르게 확인하고 싶을 때
   
   ```python
   visited = set()
   if x in visited: # O(1)
   ```

2. Key로 값을 빠르게 꺼내고 싶을 때
   
   ```python
   team = {
    "다람쥐": 28
    "고양이": 25
   }

    print(team["다람쥐"]) # O(1)
    ```

3. 많은 데이터를 빠르게 검색해야 할 때
   
   - 데이터가 아무리 많아도 속도는 O(1)로 거의 일정하다.
   - 이진탐색(O(log n))보다 훨씬 빠름
  
4. 카운틴(빈도 세기) 할 때
   
   ```python
   from collections import defaultdict

   counter = defaultdict(int)
   for word in words:
      counter[word] += 1
   ```

   - 가장 자주 쓰이는 해시테이블 응용
   - defaultdict는 dict의 확장판임
   - 없는 키를 처음 참조할 때 자동으로 초기값을 넣어준다.
   - words는 단어 리스트라고 가정
   - 단어 하나하나 돌면서 counter 딕셔너리에 개수를 1씩 증가시킨다.
   - 보통 dict에서는 키가 없으면 오류가 나는데, defaultdict는 자동으로 0부터 시작해준다.
   - 빈도수, 등장횟수, 그룹핑 → 무조건 해시!

#### ✅ 언제 안 쓰는 게 좋은가?

1. 정렬해야 할 때
   
   - 해시테이블은 순서가 없다.
  
2. 메모리를 아껴야 할 때

   - 배열을 따로 만들다 보니 메모리를 많이 잡아먹는다.

3. 보안이 중요할 때

   - 해시 충돌 공격에 취약하다.

#### ✅ 해시 함수란?

- 해시 테이블에서 가장 핵심이다.
- 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
- 즉, 일종의 주소 계산기이다.
- 위의 사물함 비유로 다시 들어가면,
- 해시함수는 "사물함 번호를 정해주는 계산기"이다.
- "다람쥐" -해시함수-> 3번 사물함
- "고양이" -해시함수-> 7번 사물함
- 파이썬에서는 hash()라는 내장함수를 사용한다.
- 면접용 한 줄 설명: "해시함수는 키 값을 입력받아서, 그걸 배열의 인덱스처럼 쓸 수 있는 고정된 숫자로 바꿔주는 함수로, 해시테이블에서 저장 위치를 빠르게 찾기 위해 사용됩니다."
  
#### ✅ 해시 충돌이란?

- 사물함 예시로 말하자면, 해시함수가 같은 사물함 번호를 부여한 경우이다.
- 다른 물건인데도 불구하고, 해시함수가 같은 번호를 준 것
- 사물함은 100개뿐인데, 물건을 1000개 넣으려 한다면 아무리 좋은 해시함수여도 번호가 겹치는 건 피할 수 없다.
- 그래서 같은 칸에 두 개의 물건이 들어가려고 싸우는 상황이 해시충돌이다.
  
#### ✅ 해시 충돌을 해결하는 방법

대표적으로 2가지가 있다.

1. 체이닝
   
   - 하나의 사물함 안에 작은 상자(리스트)를 둠
   - "다람쥐" → 3번 칸 → ["다람쥐"]
   - "고양이" → 3번 칸 → ["다람쥐", "고양이"] ← 뒤에 추가
   - C에서 많이 쓰이는 방식이다. (배열 + 연결리스트)

2. 오픈 어드레싱
   
   - 빈 사물함을 찾아서 근처로 밀어 넣기
   - "다람쥐" → 3번 칸 → OK
   - "고양이" → 3번 칸 충돌! → 4번 칸 비었네? 거기로 가자!

     → 충돌났을 때 옆으로 슬쩍 피해서 넣는 방식
   - Python의 dict, Java의 HashMap도 이 방식을 사용한다.
   
   - 🙄 근데 사물함이 꽉 차면 의미 없는 방식 아닌가요?
     
     - 그래서 실제 해시테이블 구현에서는 배열(사물함)이 꽉 차기 전에 더 큰 배열로 갈아탄다.
  
       1. 사물함이 너무 찼다!
       2. 더 큰 배열(예: 200개) 만들고
       3. 모든 기존 키를 다시 해시해서 옮김 (rehashing)

#### ✅ 해시 충돌될 확률은?

- 해시공간과 키 개수에 따라 다르다.

    | 해시공간 크기 (N) | 넣는 키 수 (k) | 충돌 확률 (대략) |
    |------------------|----------------|------------------|
    | 1,000            | 10             | 4.5%             |
    | 1,000            | 50             | 91.8% 😨         |
    | 10,000           | 100            | 약 39%           |
    | 1,000,000        | 1000           | 거의 0% 😌       |

#### ✅ 좋은 해시함수, 나쁜 해시함수

- 일단 나쁜 해시함수의 예부터 들어보자.

  ```python
  def bad_hash(key):
    return len(key) % 100
  ```

- 좋은 해시함수가 되려면, 키 값을 고르게 분포시켜서 충돌을 최소화하고, 계산이 빠르도록 해야 한다.
- 좋은 해시함수의 4가지 조건
    
    1. 균등 분포 (Uniformity): 서로 다른 키들이 해시공간 전체에 골고루 퍼져야 함
    2. 결정적 (Deterministic): 같은 입력이면 항상 같은 해시값이 나와야 함
    3. 빠른 계산 (Efficiency): 해시값을 계산하는 데 시간이 적게 걸려야 함
    4. 충돌 최소화 (Low Collisions): 서로 다른 키들이 같은 해시값을 갖지 않도록 해야 함
   
- 괜찮은 해시함수 (파이썬 내장 hash())

  ```python
  def djb2(key):
    hash = 5381
    for c in key:
        hash = ((hash << 5) + hash) + ord(c)
    return hash
  ```